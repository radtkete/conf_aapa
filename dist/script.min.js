/*
 *  Vide - v0.5.1
 *  Easy as hell jQuery plugin for video backgrounds.
 *  http://vodkabears.github.io/vide/
 *
 *  Made by Ilya Makarov
 *  Under MIT License
 */
!function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(root.jQuery);
    }
}(this, function($) {
    "use strict";
    /**
   * Name of the plugin
   * @private
   * @const
   * @type {String}
   */
    var PLUGIN_NAME = "vide";
    /**
   * Default settings
   * @private
   * @const
   * @type {Object}
   */
    var DEFAULTS = {
        volume: 1,
        playbackRate: 1,
        muted: true,
        loop: true,
        autoplay: true,
        position: "50% 50%",
        posterType: "detect",
        resizing: true,
        bgColor: "transparent",
        className: ""
    };
    /**
   * Not implemented error message
   * @private
   * @const
   * @type {String}
   */
    var NOT_IMPLEMENTED_MSG = "Not implemented";
    /**
   * Parse a string with options
   * @private
   * @param {String} str
   * @returns {Object|String}
   */
    function parseOptions(str) {
        var obj = {};
        var delimiterIndex;
        var option;
        var prop;
        var val;
        var arr;
        var len;
        var i;
        // Remove spaces around delimiters and split
        arr = str.replace(/\s*:\s*/g, ":").replace(/\s*,\s*/g, ",").split(",");
        // Parse a string
        for (i = 0, len = arr.length; i < len; i++) {
            option = arr[i];
            // Ignore urls and a string without colon delimiters
            if (option.search(/^(http|https|ftp):\/\//) !== -1 || option.search(":") === -1) {
                break;
            }
            delimiterIndex = option.indexOf(":");
            prop = option.substring(0, delimiterIndex);
            val = option.substring(delimiterIndex + 1);
            // If val is an empty string, make it undefined
            if (!val) {
                val = undefined;
            }
            // Convert a string value if it is like a boolean
            if (typeof val === "string") {
                val = val === "true" || (val === "false" ? false : val);
            }
            // Convert a string value if it is like a number
            if (typeof val === "string") {
                val = !isNaN(val) ? +val : val;
            }
            obj[prop] = val;
        }
        // If nothing is parsed
        if (prop == null && val == null) {
            return str;
        }
        return obj;
    }
    /**
   * Parse a position option
   * @private
   * @param {String} str
   * @returns {Object}
   */
    function parsePosition(str) {
        str = "" + str;
        // Default value is a center
        var args = str.split(/\s+/);
        var x = "50%";
        var y = "50%";
        var len;
        var arg;
        var i;
        for (i = 0, len = args.length; i < len; i++) {
            arg = args[i];
            // Convert values
            if (arg === "left") {
                x = "0%";
            } else if (arg === "right") {
                x = "100%";
            } else if (arg === "top") {
                y = "0%";
            } else if (arg === "bottom") {
                y = "100%";
            } else if (arg === "center") {
                if (i === 0) {
                    x = "50%";
                } else {
                    y = "50%";
                }
            } else {
                if (i === 0) {
                    x = arg;
                } else {
                    y = arg;
                }
            }
        }
        return {
            x: x,
            y: y
        };
    }
    /**
   * Search a poster
   * @private
   * @param {String} path
   * @param {Function} callback
   */
    function findPoster(path, callback) {
        var onLoad = function() {
            callback(this.src);
        };
        $('<img src="' + path + '.gif">').on("load", onLoad);
        $('<img src="' + path + '.jpg">').on("load", onLoad);
        $('<img src="' + path + '.jpeg">').on("load", onLoad);
        $('<img src="' + path + '.png">').on("load", onLoad);
    }
    /**
   * Vide constructor
   * @param {HTMLElement} element
   * @param {Object|String} path
   * @param {Object|String} options
   * @constructor
   */
    function Vide(element, path, options) {
        this.$element = $(element);
        // Parse path
        if (typeof path === "string") {
            path = parseOptions(path);
        }
        // Parse options
        if (!options) {
            options = {};
        } else if (typeof options === "string") {
            options = parseOptions(options);
        }
        // Remove an extension
        if (typeof path === "string") {
            path = path.replace(/\.\w*$/, "");
        } else if (typeof path === "object") {
            for (var i in path) {
                if (path.hasOwnProperty(i)) {
                    path[i] = path[i].replace(/\.\w*$/, "");
                }
            }
        }
        this.settings = $.extend({}, DEFAULTS, options);
        this.path = path;
        // https://github.com/VodkaBears/Vide/issues/110
        try {
            this.init();
        } catch (e) {
            if (e.message !== NOT_IMPLEMENTED_MSG) {
                throw e;
            }
        }
    }
    /**
   * Initialization
   * @public
   */
    Vide.prototype.init = function() {
        var vide = this;
        var path = vide.path;
        var poster = path;
        var sources = "";
        var $element = vide.$element;
        var settings = vide.settings;
        var position = parsePosition(settings.position);
        var posterType = settings.posterType;
        var $video;
        var $wrapper;
        // Set styles of a video wrapper
        $wrapper = vide.$wrapper = $("<div>").addClass(settings.className).css({
            position: "absolute",
            "z-index": -1,
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
            overflow: "hidden",
            "-webkit-background-size": "cover",
            "-moz-background-size": "cover",
            "-o-background-size": "cover",
            "background-size": "cover",
            "background-color": settings.bgColor,
            "background-repeat": "no-repeat",
            "background-position": position.x + " " + position.y
        });
        // Get a poster path
        if (typeof path === "object") {
            if (path.poster) {
                poster = path.poster;
            } else {
                if (path.mp4) {
                    poster = path.mp4;
                } else if (path.webm) {
                    poster = path.webm;
                } else if (path.ogv) {
                    poster = path.ogv;
                }
            }
        }
        // Set a video poster
        if (posterType === "detect") {
            findPoster(poster, function(url) {
                $wrapper.css("background-image", "url(" + url + ")");
            });
        } else if (posterType !== "none") {
            $wrapper.css("background-image", "url(" + poster + "." + posterType + ")");
        }
        // If a parent element has a static position, make it relative
        if ($element.css("position") === "static") {
            $element.css("position", "relative");
        }
        $element.prepend($wrapper);
        if (typeof path === "object") {
            if (path.mp4) {
                sources += '<source src="' + path.mp4 + '.mp4" type="video/mp4">';
            }
            if (path.webm) {
                sources += '<source src="' + path.webm + '.webm" type="video/webm">';
            }
            if (path.ogv) {
                sources += '<source src="' + path.ogv + '.ogv" type="video/ogg">';
            }
            $video = vide.$video = $("<video>" + sources + "</video>");
        } else {
            $video = vide.$video = $("<video>" + '<source src="' + path + '.mp4" type="video/mp4">' + '<source src="' + path + '.webm" type="video/webm">' + '<source src="' + path + '.ogv" type="video/ogg">' + "</video>");
        }
        // https://github.com/VodkaBears/Vide/issues/110
        try {
            $video.prop({
                autoplay: settings.autoplay,
                loop: settings.loop,
                volume: settings.volume,
                muted: settings.muted,
                defaultMuted: settings.muted,
                playbackRate: settings.playbackRate,
                defaultPlaybackRate: settings.playbackRate
            });
        } catch (e) {
            throw new Error(NOT_IMPLEMENTED_MSG);
        }
        // Video alignment
        $video.css({
            margin: "auto",
            position: "absolute",
            "z-index": -1,
            top: position.y,
            left: position.x,
            "-webkit-transform": "translate(-" + position.x + ", -" + position.y + ")",
            "-ms-transform": "translate(-" + position.x + ", -" + position.y + ")",
            "-moz-transform": "translate(-" + position.x + ", -" + position.y + ")",
            transform: "translate(-" + position.x + ", -" + position.y + ")",
            // Disable visibility, while loading
            visibility: "hidden",
            opacity: 0
        }).one("canplaythrough." + PLUGIN_NAME, function() {
            vide.resize();
        }).one("playing." + PLUGIN_NAME, function() {
            $video.css({
                visibility: "visible",
                opacity: 1
            });
            $wrapper.css("background-image", "none");
        });
        // Resize event is available only for 'window'
        // Use another code solutions to detect DOM elements resizing
        $element.on("resize." + PLUGIN_NAME, function() {
            if (settings.resizing) {
                vide.resize();
            }
        });
        // Append a video
        $wrapper.append($video);
    };
    /**
   * Get a video element
   * @public
   * @returns {HTMLVideoElement}
   */
    Vide.prototype.getVideoObject = function() {
        return this.$video[0];
    };
    /**
   * Resize a video background
   * @public
   */
    Vide.prototype.resize = function() {
        if (!this.$video) {
            return;
        }
        var $wrapper = this.$wrapper;
        var $video = this.$video;
        var video = $video[0];
        // Get a native video size
        var videoHeight = video.videoHeight;
        var videoWidth = video.videoWidth;
        // Get a wrapper size
        var wrapperHeight = $wrapper.height();
        var wrapperWidth = $wrapper.width();
        if (wrapperWidth / videoWidth > wrapperHeight / videoHeight) {
            $video.css({
                // +2 pixels to prevent an empty space after transformation
                width: wrapperWidth + 2,
                height: "auto"
            });
        } else {
            $video.css({
                width: "auto",
                // +2 pixels to prevent an empty space after transformation
                height: wrapperHeight + 2
            });
        }
    };
    /**
   * Destroy a video background
   * @public
   */
    Vide.prototype.destroy = function() {
        delete $[PLUGIN_NAME].lookup[this.index];
        this.$video && this.$video.off(PLUGIN_NAME);
        this.$element.off(PLUGIN_NAME).removeData(PLUGIN_NAME);
        this.$wrapper.remove();
    };
    /**
   * Special plugin object for instances.
   * @public
   * @type {Object}
   */
    $[PLUGIN_NAME] = {
        lookup: []
    };
    /**
   * Plugin constructor
   * @param {Object|String} path
   * @param {Object|String} options
   * @returns {JQuery}
   * @constructor
   */
    $.fn[PLUGIN_NAME] = function(path, options) {
        var instance;
        this.each(function() {
            instance = $.data(this, PLUGIN_NAME);
            // Destroy the plugin instance if exists
            instance && instance.destroy();
            // Create the plugin instance
            instance = new Vide(this, path, options);
            instance.index = $[PLUGIN_NAME].lookup.push(instance) - 1;
            $.data(this, PLUGIN_NAME, instance);
        });
        return this;
    };
    $(document).ready(function() {
        var $window = $(window);
        // Window resize event listener
        $window.on("resize." + PLUGIN_NAME, function() {
            for (var len = $[PLUGIN_NAME].lookup.length, i = 0, instance; i < len; i++) {
                instance = $[PLUGIN_NAME].lookup[i];
                if (instance && instance.settings.resizing) {
                    instance.resize();
                }
            }
        });
        // https://github.com/VodkaBears/Vide/issues/68
        $window.on("unload." + PLUGIN_NAME, function() {
            return false;
        });
        // Auto initialization
        // Add 'data-vide-bg' attribute with a path to the video without extension
        // Also you can pass options throw the 'data-vide-options' attribute
        // 'data-vide-options' must be like 'muted: false, volume: 0.5'
        $(document).find("[data-" + PLUGIN_NAME + "-bg]").each(function(i, element) {
            var $element = $(element);
            var options = $element.data(PLUGIN_NAME + "-options");
            var path = $element.data(PLUGIN_NAME + "-bg");
            $element[PLUGIN_NAME](path, options);
        });
    });
});

// Sticky Plugin v1.0.4 for jQuery
// =============
// Author: Anthony Garand
// Improvements by German M. Bravo (Kronuz) and Ruud Kamphuis (ruudk)
// Improvements by Leonardo C. Daronco (daronco)
// Created: 02/14/2011
// Date: 07/20/2015
// Website: http://stickyjs.com/
// Description: Makes an element on the page stick on the screen as you scroll
//              It will only set the 'top' and 'position' of your element, you
//              might need to adjust the width in some cases.
(function(factory) {
    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define([ "jquery" ], factory);
    } else if (typeof module === "object" && module.exports) {
        // Node/CommonJS
        module.exports = factory(require("jquery"));
    } else {
        // Browser globals
        factory(jQuery);
    }
})(function($) {
    var slice = Array.prototype.slice;
    // save ref to original slice()
    var splice = Array.prototype.splice;
    // save ref to original slice()
    var defaults = {
        topSpacing: 0,
        bottomSpacing: 0,
        className: "is-sticky",
        wrapperClassName: "sticky-wrapper",
        center: false,
        getWidthFrom: "",
        widthFromWrapper: true,
        // works only when .getWidthFrom is empty
        responsiveWidth: false,
        zIndex: "auto"
    }, $window = $(window), $document = $(document), sticked = [], windowHeight = $window.height(), scroller = function() {
        var scrollTop = $window.scrollTop(), documentHeight = $document.height(), dwh = documentHeight - windowHeight, extra = scrollTop > dwh ? dwh - scrollTop : 0;
        for (var i = 0, l = sticked.length; i < l; i++) {
            var s = sticked[i], elementTop = s.stickyWrapper.offset().top, etse = elementTop - s.topSpacing - extra;
            //update height in case of dynamic content
            s.stickyWrapper.css("height", s.stickyElement.outerHeight());
            if (scrollTop <= etse) {
                if (s.currentTop !== null) {
                    s.stickyElement.css({
                        width: "",
                        position: "",
                        top: "",
                        "z-index": ""
                    });
                    s.stickyElement.parent().removeClass(s.className);
                    s.stickyElement.trigger("sticky-end", [ s ]);
                    s.currentTop = null;
                }
            } else {
                var newTop = documentHeight - s.stickyElement.outerHeight() - s.topSpacing - s.bottomSpacing - scrollTop - extra;
                if (newTop < 0) {
                    newTop = newTop + s.topSpacing;
                } else {
                    newTop = s.topSpacing;
                }
                if (s.currentTop !== newTop) {
                    var newWidth;
                    if (s.getWidthFrom) {
                        newWidth = $(s.getWidthFrom).width() || null;
                    } else if (s.widthFromWrapper) {
                        newWidth = s.stickyWrapper.width();
                    }
                    if (newWidth == null) {
                        newWidth = s.stickyElement.width();
                    }
                    s.stickyElement.css("width", newWidth).css("position", "fixed").css("top", newTop).css("z-index", s.zIndex);
                    s.stickyElement.parent().addClass(s.className);
                    if (s.currentTop === null) {
                        s.stickyElement.trigger("sticky-start", [ s ]);
                    } else {
                        // sticky is started but it have to be repositioned
                        s.stickyElement.trigger("sticky-update", [ s ]);
                    }
                    if (s.currentTop === s.topSpacing && s.currentTop > newTop || s.currentTop === null && newTop < s.topSpacing) {
                        // just reached bottom || just started to stick but bottom is already reached
                        s.stickyElement.trigger("sticky-bottom-reached", [ s ]);
                    } else if (s.currentTop !== null && newTop === s.topSpacing && s.currentTop < newTop) {
                        // sticky is started && sticked at topSpacing && overflowing from top just finished
                        s.stickyElement.trigger("sticky-bottom-unreached", [ s ]);
                    }
                    s.currentTop = newTop;
                }
                // Check if sticky has reached end of container and stop sticking
                var stickyWrapperContainer = s.stickyWrapper.parent();
                var unstick = s.stickyElement.offset().top + s.stickyElement.outerHeight() >= stickyWrapperContainer.offset().top + stickyWrapperContainer.outerHeight() && s.stickyElement.offset().top <= s.topSpacing;
                if (unstick) {
                    s.stickyElement.css("position", "absolute").css("top", "").css("bottom", 0).css("z-index", "");
                } else {
                    s.stickyElement.css("position", "fixed").css("top", newTop).css("bottom", "").css("z-index", s.zIndex);
                }
            }
        }
    }, resizer = function() {
        windowHeight = $window.height();
        for (var i = 0, l = sticked.length; i < l; i++) {
            var s = sticked[i];
            var newWidth = null;
            if (s.getWidthFrom) {
                if (s.responsiveWidth) {
                    newWidth = $(s.getWidthFrom).width();
                }
            } else if (s.widthFromWrapper) {
                newWidth = s.stickyWrapper.width();
            }
            if (newWidth != null) {
                s.stickyElement.css("width", newWidth);
            }
        }
    }, methods = {
        init: function(options) {
            return this.each(function() {
                var o = $.extend({}, defaults, options);
                var stickyElement = $(this);
                var stickyId = stickyElement.attr("id");
                var wrapperId = stickyId ? stickyId + "-" + defaults.wrapperClassName : defaults.wrapperClassName;
                var wrapper = $("<div></div>").attr("id", wrapperId).addClass(o.wrapperClassName);
                stickyElement.wrapAll(function() {
                    if ($(this).parent("#" + wrapperId).length == 0) {
                        return wrapper;
                    }
                });
                var stickyWrapper = stickyElement.parent();
                if (o.center) {
                    stickyWrapper.css({
                        width: stickyElement.outerWidth(),
                        marginLeft: "auto",
                        marginRight: "auto"
                    });
                }
                if (stickyElement.css("float") === "right") {
                    stickyElement.css({
                        float: "none"
                    }).parent().css({
                        float: "right"
                    });
                }
                o.stickyElement = stickyElement;
                o.stickyWrapper = stickyWrapper;
                o.currentTop = null;
                sticked.push(o);
                methods.setWrapperHeight(this);
                methods.setupChangeListeners(this);
            });
        },
        setWrapperHeight: function(stickyElement) {
            var element = $(stickyElement);
            var stickyWrapper = element.parent();
            if (stickyWrapper) {
                stickyWrapper.css("height", element.outerHeight());
            }
        },
        setupChangeListeners: function(stickyElement) {
            if (window.MutationObserver) {
                var mutationObserver = new window.MutationObserver(function(mutations) {
                    if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) {
                        methods.setWrapperHeight(stickyElement);
                    }
                });
                mutationObserver.observe(stickyElement, {
                    subtree: true,
                    childList: true
                });
            } else {
                if (window.addEventListener) {
                    stickyElement.addEventListener("DOMNodeInserted", function() {
                        methods.setWrapperHeight(stickyElement);
                    }, false);
                    stickyElement.addEventListener("DOMNodeRemoved", function() {
                        methods.setWrapperHeight(stickyElement);
                    }, false);
                } else if (window.attachEvent) {
                    stickyElement.attachEvent("onDOMNodeInserted", function() {
                        methods.setWrapperHeight(stickyElement);
                    });
                    stickyElement.attachEvent("onDOMNodeRemoved", function() {
                        methods.setWrapperHeight(stickyElement);
                    });
                }
            }
        },
        update: scroller,
        unstick: function(options) {
            return this.each(function() {
                var that = this;
                var unstickyElement = $(that);
                var removeIdx = -1;
                var i = sticked.length;
                while (i-- > 0) {
                    if (sticked[i].stickyElement.get(0) === that) {
                        splice.call(sticked, i, 1);
                        removeIdx = i;
                    }
                }
                if (removeIdx !== -1) {
                    unstickyElement.unwrap();
                    unstickyElement.css({
                        width: "",
                        position: "",
                        top: "",
                        float: "",
                        "z-index": ""
                    });
                }
            });
        }
    };
    // should be more efficient than using $window.scroll(scroller) and $window.resize(resizer):
    if (window.addEventListener) {
        window.addEventListener("scroll", scroller, false);
        window.addEventListener("resize", resizer, false);
    } else if (window.attachEvent) {
        window.attachEvent("onscroll", scroller);
        window.attachEvent("onresize", resizer);
    }
    $.fn.sticky = function(method) {
        if (methods[method]) {
            return methods[method].apply(this, slice.call(arguments, 1));
        } else if (typeof method === "object" || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error("Method " + method + " does not exist on jQuery.sticky");
        }
    };
    $.fn.unstick = function(method) {
        if (methods[method]) {
            return methods[method].apply(this, slice.call(arguments, 1));
        } else if (typeof method === "object" || !method) {
            return methods.unstick.apply(this, arguments);
        } else {
            $.error("Method " + method + " does not exist on jQuery.sticky");
        }
    };
    $(function() {
        setTimeout(scroller, 0);
    });
});

/*!
 * smooth-scroll v10.2.1: Animate scrolling to anchor links
 * (c) 2016 Chris Ferdinandi
 * MIT License
 * http://github.com/cferdinandi/smooth-scroll
 */
(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], factory(root));
    } else if (typeof exports === "object") {
        module.exports = factory(root);
    } else {
        root.smoothScroll = factory(root);
    }
})(typeof global !== "undefined" ? global : this.window || this.global, function(root) {
    "use strict";
    //
    // Variables
    //
    var smoothScroll = {};
    // Object for public APIs
    var supports = "querySelector" in document && "addEventListener" in root;
    // Feature test
    var settings, anchor, toggle, fixedHeader, headerHeight, eventTimeout, animationInterval;
    // Default settings
    var defaults = {
        selector: "[data-scroll]",
        selectorHeader: null,
        speed: 500,
        easing: "easeInOutCubic",
        offset: 0,
        callback: function() {}
    };
    //
    // Methods
    //
    /**
     * Merge two or more objects. Returns a new object.
     * @private
     * @param {Boolean}  deep     If true, do a deep (or recursive) merge [optional]
     * @param {Object}   objects  The objects to merge together
     * @returns {Object}          Merged values of defaults and options
     */
    var extend = function() {
        // Variables
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;
        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === "[object Boolean]") {
            deep = arguments[0];
            i++;
        }
        // Merge the object into the extended object
        var merge = function(obj) {
            for (var prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    // If deep merge and property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === "[object Object]") {
                        extended[prop] = extend(true, extended[prop], obj[prop]);
                    } else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };
        // Loop through each object and conduct a merge
        for (;i < length; i++) {
            var obj = arguments[i];
            merge(obj);
        }
        return extended;
    };
    /**
     * Get the height of an element.
     * @private
     * @param  {Node} elem The element to get the height of
     * @return {Number}    The element's height in pixels
     */
    var getHeight = function(elem) {
        return Math.max(elem.scrollHeight, elem.offsetHeight, elem.clientHeight);
    };
    /**
     * Get the closest matching element up the DOM tree.
     * @private
     * @param  {Element} elem     Starting element
     * @param  {String}  selector Selector to match against
     * @return {Boolean|Element}  Returns null if not match found
     */
    var getClosest = function(elem, selector) {
        // Element.matches() polyfill
        if (!Element.prototype.matches) {
            Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {
                var matches = (this.document || this.ownerDocument).querySelectorAll(s), i = matches.length;
                while (--i >= 0 && matches.item(i) !== this) {}
                return i > -1;
            };
        }
        // Get closest match
        for (;elem && elem !== document; elem = elem.parentNode) {
            if (elem.matches(selector)) return elem;
        }
        return null;
    };
    /**
     * Escape special characters for use with querySelector
     * @private
     * @param {String} id The anchor ID to escape
     * @author Mathias Bynens
     * @link https://github.com/mathiasbynens/CSS.escape
     */
    var escapeCharacters = function(id) {
        // Remove leading hash
        if (id.charAt(0) === "#") {
            id = id.substr(1);
        }
        var string = String(id);
        var length = string.length;
        var index = -1;
        var codeUnit;
        var result = "";
        var firstCodeUnit = string.charCodeAt(0);
        while (++index < length) {
            codeUnit = string.charCodeAt(index);
            // Note: there’s no need to special-case astral symbols, surrogate
            // pairs, or lone surrogates.
            // If the character is NULL (U+0000), then throw an
            // `InvalidCharacterError` exception and terminate these steps.
            if (codeUnit === 0) {
                throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
            }
            if (// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, […]
            codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), […]
            index === 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
            index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45) {
                // http://dev.w3.org/csswg/cssom/#escape-a-character-as-code-point
                result += "\\" + codeUnit.toString(16) + " ";
                continue;
            }
            // If the character is not handled by one of the above rules and is
            // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
            // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
            // U+005A), or [a-z] (U+0061 to U+007A), […]
            if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
                // the character itself
                result += string.charAt(index);
                continue;
            }
            // Otherwise, the escaped character.
            // http://dev.w3.org/csswg/cssom/#escape-a-character
            result += "\\" + string.charAt(index);
        }
        return "#" + result;
    };
    /**
     * Calculate the easing pattern
     * @private
     * @link https://gist.github.com/gre/1650294
     * @param {String} type Easing pattern
     * @param {Number} time Time animation should take to complete
     * @returns {Number}
     */
    var easingPattern = function(type, time) {
        var pattern;
        if (type === "easeInQuad") pattern = time * time;
        // accelerating from zero velocity
        if (type === "easeOutQuad") pattern = time * (2 - time);
        // decelerating to zero velocity
        if (type === "easeInOutQuad") pattern = time < .5 ? 2 * time * time : -1 + (4 - 2 * time) * time;
        // acceleration until halfway, then deceleration
        if (type === "easeInCubic") pattern = time * time * time;
        // accelerating from zero velocity
        if (type === "easeOutCubic") pattern = --time * time * time + 1;
        // decelerating to zero velocity
        if (type === "easeInOutCubic") pattern = time < .5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        // acceleration until halfway, then deceleration
        if (type === "easeInQuart") pattern = time * time * time * time;
        // accelerating from zero velocity
        if (type === "easeOutQuart") pattern = 1 - --time * time * time * time;
        // decelerating to zero velocity
        if (type === "easeInOutQuart") pattern = time < .5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time;
        // acceleration until halfway, then deceleration
        if (type === "easeInQuint") pattern = time * time * time * time * time;
        // accelerating from zero velocity
        if (type === "easeOutQuint") pattern = 1 + --time * time * time * time * time;
        // decelerating to zero velocity
        if (type === "easeInOutQuint") pattern = time < .5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time;
        // acceleration until halfway, then deceleration
        return pattern || time;
    };
    /**
     * Calculate how far to scroll
     * @private
     * @param {Element} anchor The anchor element to scroll to
     * @param {Number} headerHeight Height of a fixed header, if any
     * @param {Number} offset Number of pixels by which to offset scroll
     * @returns {Number}
     */
    var getEndLocation = function(anchor, headerHeight, offset) {
        var location = 0;
        if (anchor.offsetParent) {
            do {
                location += anchor.offsetTop;
                anchor = anchor.offsetParent;
            } while (anchor);
        }
        location = Math.max(location - headerHeight - offset, 0);
        return Math.min(location, getDocumentHeight() - getViewportHeight());
    };
    /**
     * Determine the viewport's height
     * @private
     * @returns {Number}
     */
    var getViewportHeight = function() {
        return Math.max(document.documentElement.clientHeight, root.innerHeight || 0);
    };
    /**
     * Determine the document's height
     * @private
     * @returns {Number}
     */
    var getDocumentHeight = function() {
        return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
    };
    /**
     * Convert data-options attribute into an object of key/value pairs
     * @private
     * @param {String} options Link-specific options as a data attribute string
     * @returns {Object}
     */
    var getDataOptions = function(options) {
        return !options || !(typeof JSON === "object" && typeof JSON.parse === "function") ? {} : JSON.parse(options);
    };
    /**
     * Get the height of the fixed header
     * @private
     * @param  {Node}   header The header
     * @return {Number}        The height of the header
     */
    var getHeaderHeight = function(header) {
        return !header ? 0 : getHeight(header) + header.offsetTop;
    };
    /**
     * Bring the anchored element into focus
     * @private
     */
    var adjustFocus = function(anchor, endLocation, isNum) {
        // Don't run if scrolling to a number on the page
        if (isNum) return;
        // Otherwise, bring anchor element into focus
        anchor.focus();
        if (document.activeElement.id !== anchor.id) {
            anchor.setAttribute("tabindex", "-1");
            anchor.focus();
            anchor.style.outline = "none";
        }
        root.scrollTo(0, endLocation);
    };
    /**
     * Start/stop the scrolling animation
     * @public
     * @param {Node|Number} anchor  The element or position to scroll to
     * @param {Element}     toggle  The element that toggled the scroll event
     * @param {Object}      options
     */
    smoothScroll.animateScroll = function(anchor, toggle, options) {
        // Options and overrides
        var overrides = getDataOptions(toggle ? toggle.getAttribute("data-options") : null);
        var animateSettings = extend(settings || defaults, options || {}, overrides);
        // Merge user options with defaults
        // Selectors and variables
        var isNum = Object.prototype.toString.call(anchor) === "[object Number]" ? true : false;
        var anchorElem = isNum || !anchor.tagName ? null : anchor;
        if (!isNum && !anchorElem) return;
        var startLocation = root.pageYOffset;
        // Current location on the page
        if (animateSettings.selectorHeader && !fixedHeader) {
            // Get the fixed header if not already set
            fixedHeader = document.querySelector(animateSettings.selectorHeader);
        }
        if (!headerHeight) {
            // Get the height of a fixed header if one exists and not already set
            headerHeight = getHeaderHeight(fixedHeader);
        }
        var endLocation = isNum ? anchor : getEndLocation(anchorElem, headerHeight, parseInt(animateSettings.offset, 10));
        // Location to scroll to
        var distance = endLocation - startLocation;
        // distance to travel
        var documentHeight = getDocumentHeight();
        var timeLapsed = 0;
        var percentage, position;
        /**
         * Stop the scroll animation when it reaches its target (or the bottom/top of page)
         * @private
         * @param {Number} position Current position on the page
         * @param {Number} endLocation Scroll to location
         * @param {Number} animationInterval How much to scroll on this loop
         */
        var stopAnimateScroll = function(position, endLocation, animationInterval) {
            var currentLocation = root.pageYOffset;
            if (position == endLocation || currentLocation == endLocation || root.innerHeight + currentLocation >= documentHeight) {
                // Clear the animation timer
                clearInterval(animationInterval);
                // Bring the anchored element into focus
                adjustFocus(anchor, endLocation, isNum);
                // Run callback after animation complete
                animateSettings.callback(anchor, toggle);
            }
        };
        /**
         * Loop scrolling animation
         * @private
         */
        var loopAnimateScroll = function() {
            timeLapsed += 16;
            percentage = timeLapsed / parseInt(animateSettings.speed, 10);
            percentage = percentage > 1 ? 1 : percentage;
            position = startLocation + distance * easingPattern(animateSettings.easing, percentage);
            root.scrollTo(0, Math.floor(position));
            stopAnimateScroll(position, endLocation, animationInterval);
        };
        /**
         * Set interval timer
         * @private
         */
        var startAnimateScroll = function() {
            clearInterval(animationInterval);
            animationInterval = setInterval(loopAnimateScroll, 16);
        };
        /**
         * Reset position to fix weird iOS bug
         * @link https://github.com/cferdinandi/smooth-scroll/issues/45
         */
        if (root.pageYOffset === 0) {
            root.scrollTo(0, 0);
        }
        // Start scrolling animation
        startAnimateScroll();
    };
    /**
     * Handle has change event
     * @private
     */
    var hashChangeHandler = function(event) {
        // Get hash from URL
        // var hash = decodeURIComponent( escapeCharacters( root.location.hash ) );
        var hash;
        try {
            hash = escapeCharacters(decodeURIComponent(root.location.hash));
        } catch (e) {
            hash = escapeCharacters(root.location.hash);
        }
        // Only run if there's an anchor element to scroll to
        if (!anchor) return;
        // Reset the anchor element's ID
        anchor.id = anchor.getAttribute("data-scroll-id");
        // Scroll to the anchored content
        smoothScroll.animateScroll(anchor, toggle);
        // Reset anchor and toggle
        anchor = null;
        toggle = null;
    };
    /**
     * If smooth scroll element clicked, animate scroll
     * @private
     */
    var clickHandler = function(event) {
        // Don't run if right-click or command/control + click
        if (event.button !== 0 || event.metaKey || event.ctrlKey) return;
        // Check if a smooth scroll link was clicked
        toggle = getClosest(event.target, settings.selector);
        if (!toggle || toggle.tagName.toLowerCase() !== "a") return;
        // Only run if link is an anchor and points to the current page
        if (toggle.hostname !== root.location.hostname || toggle.pathname !== root.location.pathname || !/#/.test(toggle.href)) return;
        // Get the sanitized hash
        // var hash = decodeURIComponent( escapeCharacters( toggle.hash ) );
        // console.log(hash);
        var hash;
        try {
            hash = escapeCharacters(decodeURIComponent(toggle.hash));
        } catch (e) {
            hash = escapeCharacters(toggle.hash);
        }
        // If the hash is empty, scroll to the top of the page
        if (hash === "#") {
            // Prevent default link behavior
            event.preventDefault();
            // Set the anchored element
            anchor = document.body;
            // Save or create the ID as a data attribute and remove it (prevents scroll jump)
            var id = anchor.id ? anchor.id : "smooth-scroll-top";
            anchor.setAttribute("data-scroll-id", id);
            anchor.id = "";
            // If no hash change event will happen, fire manually
            // Otherwise, update the hash
            if (root.location.hash.substring(1) === id) {
                hashChangeHandler();
            } else {
                root.location.hash = id;
            }
            return;
        }
        // Get the anchored element
        anchor = document.querySelector(hash);
        // If anchored element exists, save the ID as a data attribute and remove it (prevents scroll jump)
        if (!anchor) return;
        anchor.setAttribute("data-scroll-id", anchor.id);
        anchor.id = "";
        // If no hash change event will happen, fire manually
        if (toggle.hash === root.location.hash) {
            event.preventDefault();
            hashChangeHandler();
        }
    };
    /**
     * On window scroll and resize, only run events at a rate of 15fps for better performance
     * @private
     * @param  {Function} eventTimeout Timeout function
     * @param  {Object} settings
     */
    var resizeThrottler = function(event) {
        if (!eventTimeout) {
            eventTimeout = setTimeout(function() {
                eventTimeout = null;
                // Reset timeout
                headerHeight = getHeaderHeight(fixedHeader);
            }, 66);
        }
    };
    /**
     * Destroy the current initialization.
     * @public
     */
    smoothScroll.destroy = function() {
        // If plugin isn't already initialized, stop
        if (!settings) return;
        // Remove event listeners
        document.removeEventListener("click", clickHandler, false);
        root.removeEventListener("resize", resizeThrottler, false);
        // Reset varaibles
        settings = null;
        anchor = null;
        toggle = null;
        fixedHeader = null;
        headerHeight = null;
        eventTimeout = null;
        animationInterval = null;
    };
    /**
     * Initialize Smooth Scroll
     * @public
     * @param {Object} options User settings
     */
    smoothScroll.init = function(options) {
        // feature test
        if (!supports) return;
        // Destroy any existing initializations
        smoothScroll.destroy();
        // Selectors and variables
        settings = extend(defaults, options || {});
        // Merge user options with defaults
        fixedHeader = settings.selectorHeader ? document.querySelector(settings.selectorHeader) : null;
        // Get the fixed header
        headerHeight = getHeaderHeight(fixedHeader);
        // When a toggle is clicked, run the click handler
        document.addEventListener("click", clickHandler, false);
        // Listen for hash changes
        root.addEventListener("hashchange", hashChangeHandler, false);
        // If window is resized and there's a fixed header, recalculate its size
        if (fixedHeader) {
            root.addEventListener("resize", resizeThrottler, false);
        }
    };
    //
    // Public APIs
    //
    return smoothScroll;
});

(function($) {
    "use strict";
    // Start of use strict
    init_scroll_navigate();
    $(window).trigger("scroll");
    $(window).trigger("resize");
    $(document).ready(function() {
        $(window).trigger("resize");
        init_mobile_nav_toggle();
        init_classic_menu();
        video_bg_init();
    });
    $(window).resize(function() {
        init_classic_menu_resize();
        js_height_init();
    });
    function init_classic_menu_resize() {
        // Mobile menu style toggle
        if ($(window).width() <= 899) {
            $(".navigation").addClass("mobile-on");
        } else if ($(window).width() > 899) {
            $(".navigation").removeClass("mobile-on");
        }
    }
    function init_classic_menu() {
        // Navbar sticky
        $(window).bind("scroll", function() {
            if ($(window).scrollTop() > $(".home-section").height()) {
                $(".navigation").sticky({
                    topSpacing: 0
                });
            } else {
                $(".navigation").unstick();
            }
        });
    }
    // Hamburger Menu - Toggle
    function init_mobile_nav_toggle() {
        var hamburger = $("#js-mobile-menu").off();
        var desktop_nav = $("#js-navigation-menu");
        desktop_nav.removeClass("show");
        hamburger.on("click", function(e) {
            e.preventDefault();
            this.classList.contains("is-active") === true ? this.classList.remove("is-active") : this.classList.add("is-active");
            desktop_nav.slideToggle(function() {
                if ($(this).is(":hidden")) {
                    $(this).removeAttr("style");
                }
            });
        });
    }
})(jQuery);

// End of use strict
function video_bg_init() {
    $("#video-bg").vide({
        mp4: "video/newOrleans",
        webm: "video/newOrleans",
        ogv: "video/newOrleans",
        poster: "video/newOrleans.jpg"
    }, {
        position: "50% 50%",
        posterType: "jpg"
    });
}

function js_height_init() {
    (function($) {
        $(".js-height-full").height($(window).height());
        $(".js-height-parent").each(function() {
            $(this).height($(this).parent().first().height());
        });
    })(jQuery);
}

// Sub menu
var mnHasSub = $(".mn-has-sub");

var mnThisLi;

$(".mobile-on .mn-has-sub").find(".fa:first").removeClass("fa-angle-right").addClass("fa-angle-down");

mnHasSub.click(function() {
    if ($(".navigation").hasClass("mobile-on")) {
        mnThisLi = $(this).parent("li:first");
        if (mnThisLi.hasClass("js-opened")) {
            mnThisLi.find(".submenu:first").slideUp(function() {
                mnThisLi.removeClass("js-opened");
                mnThisLi.find(".mn-has-sub").find(".fa:first").removeClass("fa-angle-up").addClass("fa-angle-down");
            });
        } else {
            $(this).find(".fa:first").removeClass("fa-angle-down").addClass("fa-angle-up");
            mnThisLi.addClass("js-opened");
            mnThisLi.find(".submenu:first").slideDown();
        }
        return false;
    } else {}
});

mnThisLi = mnHasSub.parent("li");

mnThisLi.hover(function() {
    if (!$(".navigation").hasClass("mobile-on")) {
        $(this).find(".submenu:first").stop(true, true).fadeIn("fast");
    }
}, function() {
    if (!$(".navigation").hasClass("mobile-on")) {
        $(this).find(".submenu:first").stop(true, true).delay(100).fadeOut("fast");
    }
});

// Countdown Init Init
$(document).ready(function() {
    var countdown = $(".countdown");
    var data_finish_date = countdown.attr("data-finish-date");
    var data_UTC = countdown.attr("data-UTC");
    var data_finish_message = countdown.attr("data-finish-message");
    countdown.downCount({
        date: data_finish_date,
        offset: data_UTC
    }, function() {
        alert(data_finish_message);
    });
});

/**
 * downCount: Simple Countdown clock with offset
 * Author: Sonny T. <hi@sonnyt.com>, sonnyt.com
 */
(function($) {
    $.fn.downCount = function(options, callback) {
        var settings = $.extend({
            date: null,
            offset: null
        }, options);
        // Throw error if date is not set
        if (!settings.date) {
            $.error("Date is not defined.");
        }
        // Throw error if date is set incorectly
        if (!Date.parse(settings.date)) {
            $.error("Incorrect date format, it should look like this, 12/24/2012 12:00:00.");
        }
        // Save container
        var container = this;
        /**
         * Change client's local date to match offset timezone
         * @return {Object} Fixed Date object.
         */
        var currentDate = function() {
            // get client's current date
            var date = new Date();
            // turn date to utc
            var utc = date.getTime() + date.getTimezoneOffset() * 6e4;
            // set new Date object
            var new_date = new Date(utc + 36e5 * settings.offset);
            return new_date;
        };
        /**
         * Main downCount function that calculates everything
         */
        function countdown() {
            var target_date = new Date(settings.date), // set target date
            current_date = currentDate();
            // get fixed current date
            // difference of dates
            var difference = target_date - current_date;
            // if difference is negative than it's pass the target date
            if (difference < 0) {
                // stop timer
                clearInterval(interval);
                if (callback && typeof callback === "function") callback();
                return;
            }
            // basic math variables
            var _second = 1e3, _minute = _second * 60, _hour = _minute * 60, _day = _hour * 24;
            // calculate dates
            var days = Math.floor(difference / _day), hours = Math.floor(difference % _day / _hour), minutes = Math.floor(difference % _hour / _minute), seconds = Math.floor(difference % _minute / _second);
            // fix dates so that it will show two digets
            days = String(days).length >= 2 ? days : "0" + days;
            hours = String(hours).length >= 2 ? hours : "0" + hours;
            minutes = String(minutes).length >= 2 ? minutes : "0" + minutes;
            seconds = String(seconds).length >= 2 ? seconds : "0" + seconds;
            // based on the date change the refrence wording
            var ref_days = days === 1 ? "day" : "days", ref_hours = hours === 1 ? "hour" : "hours", ref_minutes = minutes === 1 ? "minute" : "minutes", ref_seconds = seconds === 1 ? "second" : "seconds";
            // set to DOM
            container.find(".days").text(days);
            container.find(".hours").text(hours);
            container.find(".minutes").text(minutes);
            container.find(".seconds").text(seconds);
            container.find(".days_ref").text(ref_days);
            container.find(".hours_ref").text(ref_hours);
            container.find(".minutes_ref").text(ref_minutes);
            container.find(".seconds_ref").text(ref_seconds);
        }
        // start
        var interval = setInterval(countdown, 300);
    };
})(jQuery);

(function() {
    "use strict";
    /**
   * tabs
   *
   * @description The Tabs component.
   * @param {Object} options The options hash
   */
    var tabs = function(options) {
        var el = document.querySelector(options.el);
        var tabNavigationLinks = el.querySelectorAll(options.tabNavigationLinks);
        var tabContentContainers = el.querySelectorAll(options.tabContentContainers);
        var activeIndex = 0;
        var initCalled = false;
        /**
     * init
     *
     * @description Initializes the component by removing the no-js class from
     *   the component, and attaching event listeners to each of the nav items.
     *   Returns nothing.
     */
        var init = function() {
            if (!initCalled) {
                initCalled = true;
                el.classList.remove("no-js");
                for (var i = 0; i < tabNavigationLinks.length; i++) {
                    var link = tabNavigationLinks[i];
                    handleClick(link, i);
                }
            }
        };
        /**
     * handleClick
     *
     * @description Handles click event listeners on each of the links in the
     *   tab navigation. Returns nothing.
     * @param {HTMLElement} link The link to listen for events on
     * @param {Number} index The index of that link
     */
        var handleClick = function(link, index) {
            link.addEventListener("click", function(e) {
                e.preventDefault();
                goToTab(index);
            });
        };
        /**
     * goToTab
     *
     * @description Goes to a specific tab based on index. Returns nothing.
     * @param {Number} index The index of the tab to go to
     */
        var goToTab = function(index) {
            if (index !== activeIndex && index >= 0 && index <= tabNavigationLinks.length) {
                tabNavigationLinks[activeIndex].classList.remove("is-active");
                tabNavigationLinks[index].classList.add("is-active");
                tabContentContainers[activeIndex].classList.remove("is-active");
                tabContentContainers[index].classList.add("is-active");
                activeIndex = index;
            }
        };
        /**
     * Returns init and goToTab
     */
        return {
            init: init,
            goToTab: goToTab
        };
    };
    /**
   * Attach to global namespace
   */
    window.tabs = tabs;
})();

/* ---------------------------------------------
     Scroll navigation
     --------------------------------------------- */
function init_scroll_navigate() {
    $('a[href*="#"]:not([href="#"])').click(function() {
        if (location.pathname.replace(/^\//, "") == this.pathname.replace(/^\//, "") && location.hostname == this.hostname) {
            var target = $(this.hash);
            target = target.length ? target : $("[name=" + this.hash.slice(1) + "]");
            if (target.length) {
                $("html, body").animate({
                    scrollTop: target.offset().top
                }, 1e3);
                return false;
            }
        }
    });
}

$(document).ready(function() {
    if ($("#js-parallax-window").length) {
        parallax();
    }
});

$(window).scroll(function(e) {
    if ($("#js-parallax-window").length) {
        parallax();
    }
});

function parallax() {
    if ($("#js-parallax-window").length > 0) {
        var plxBackground = $("#js-parallax-background");
        var plxWindow = $("#js-parallax-window");
        var plxWindowTopToPageTop = $(plxWindow).offset().top;
        var windowTopToPageTop = $(window).scrollTop();
        var plxWindowTopToWindowTop = plxWindowTopToPageTop - windowTopToPageTop;
        var plxBackgroundTopToPageTop = $(plxBackground).offset().top;
        var windowInnerHeight = window.innerHeight;
        var plxBackgroundTopToWindowTop = plxBackgroundTopToPageTop - windowTopToPageTop;
        var plxBackgroundTopToWindowBottom = windowInnerHeight - plxBackgroundTopToWindowTop;
        var plxSpeed = .35;
        plxBackground.css("top", -(plxWindowTopToWindowTop * plxSpeed) + "px");
    }
}