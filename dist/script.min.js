/*
 *  Vide - v0.5.1
 *  Easy as hell jQuery plugin for video backgrounds.
 *  http://vodkabears.github.io/vide/
 *
 *  Made by Ilya Makarov
 *  Under MIT License
 */
!function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(root.jQuery);
    }
}(this, function($) {
    "use strict";
    /**
   * Name of the plugin
   * @private
   * @const
   * @type {String}
   */
    var PLUGIN_NAME = "vide";
    /**
   * Default settings
   * @private
   * @const
   * @type {Object}
   */
    var DEFAULTS = {
        volume: 1,
        playbackRate: 1,
        muted: true,
        loop: true,
        autoplay: true,
        position: "50% 50%",
        posterType: "detect",
        resizing: true,
        bgColor: "transparent",
        className: ""
    };
    /**
   * Not implemented error message
   * @private
   * @const
   * @type {String}
   */
    var NOT_IMPLEMENTED_MSG = "Not implemented";
    /**
   * Parse a string with options
   * @private
   * @param {String} str
   * @returns {Object|String}
   */
    function parseOptions(str) {
        var obj = {};
        var delimiterIndex;
        var option;
        var prop;
        var val;
        var arr;
        var len;
        var i;
        // Remove spaces around delimiters and split
        arr = str.replace(/\s*:\s*/g, ":").replace(/\s*,\s*/g, ",").split(",");
        // Parse a string
        for (i = 0, len = arr.length; i < len; i++) {
            option = arr[i];
            // Ignore urls and a string without colon delimiters
            if (option.search(/^(http|https|ftp):\/\//) !== -1 || option.search(":") === -1) {
                break;
            }
            delimiterIndex = option.indexOf(":");
            prop = option.substring(0, delimiterIndex);
            val = option.substring(delimiterIndex + 1);
            // If val is an empty string, make it undefined
            if (!val) {
                val = undefined;
            }
            // Convert a string value if it is like a boolean
            if (typeof val === "string") {
                val = val === "true" || (val === "false" ? false : val);
            }
            // Convert a string value if it is like a number
            if (typeof val === "string") {
                val = !isNaN(val) ? +val : val;
            }
            obj[prop] = val;
        }
        // If nothing is parsed
        if (prop == null && val == null) {
            return str;
        }
        return obj;
    }
    /**
   * Parse a position option
   * @private
   * @param {String} str
   * @returns {Object}
   */
    function parsePosition(str) {
        str = "" + str;
        // Default value is a center
        var args = str.split(/\s+/);
        var x = "50%";
        var y = "50%";
        var len;
        var arg;
        var i;
        for (i = 0, len = args.length; i < len; i++) {
            arg = args[i];
            // Convert values
            if (arg === "left") {
                x = "0%";
            } else if (arg === "right") {
                x = "100%";
            } else if (arg === "top") {
                y = "0%";
            } else if (arg === "bottom") {
                y = "100%";
            } else if (arg === "center") {
                if (i === 0) {
                    x = "50%";
                } else {
                    y = "50%";
                }
            } else {
                if (i === 0) {
                    x = arg;
                } else {
                    y = arg;
                }
            }
        }
        return {
            x: x,
            y: y
        };
    }
    /**
   * Search a poster
   * @private
   * @param {String} path
   * @param {Function} callback
   */
    function findPoster(path, callback) {
        var onLoad = function() {
            callback(this.src);
        };
        $('<img src="' + path + '.gif">').on("load", onLoad);
        $('<img src="' + path + '.jpg">').on("load", onLoad);
        $('<img src="' + path + '.jpeg">').on("load", onLoad);
        $('<img src="' + path + '.png">').on("load", onLoad);
    }
    /**
   * Vide constructor
   * @param {HTMLElement} element
   * @param {Object|String} path
   * @param {Object|String} options
   * @constructor
   */
    function Vide(element, path, options) {
        this.$element = $(element);
        // Parse path
        if (typeof path === "string") {
            path = parseOptions(path);
        }
        // Parse options
        if (!options) {
            options = {};
        } else if (typeof options === "string") {
            options = parseOptions(options);
        }
        // Remove an extension
        if (typeof path === "string") {
            path = path.replace(/\.\w*$/, "");
        } else if (typeof path === "object") {
            for (var i in path) {
                if (path.hasOwnProperty(i)) {
                    path[i] = path[i].replace(/\.\w*$/, "");
                }
            }
        }
        this.settings = $.extend({}, DEFAULTS, options);
        this.path = path;
        // https://github.com/VodkaBears/Vide/issues/110
        try {
            this.init();
        } catch (e) {
            if (e.message !== NOT_IMPLEMENTED_MSG) {
                throw e;
            }
        }
    }
    /**
   * Initialization
   * @public
   */
    Vide.prototype.init = function() {
        var vide = this;
        var path = vide.path;
        var poster = path;
        var sources = "";
        var $element = vide.$element;
        var settings = vide.settings;
        var position = parsePosition(settings.position);
        var posterType = settings.posterType;
        var $video;
        var $wrapper;
        // Set styles of a video wrapper
        $wrapper = vide.$wrapper = $("<div>").addClass(settings.className).css({
            position: "absolute",
            "z-index": -1,
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
            overflow: "hidden",
            "-webkit-background-size": "cover",
            "-moz-background-size": "cover",
            "-o-background-size": "cover",
            "background-size": "cover",
            "background-color": settings.bgColor,
            "background-repeat": "no-repeat",
            "background-position": position.x + " " + position.y
        });
        // Get a poster path
        if (typeof path === "object") {
            if (path.poster) {
                poster = path.poster;
            } else {
                if (path.mp4) {
                    poster = path.mp4;
                } else if (path.webm) {
                    poster = path.webm;
                } else if (path.ogv) {
                    poster = path.ogv;
                }
            }
        }
        // Set a video poster
        if (posterType === "detect") {
            findPoster(poster, function(url) {
                $wrapper.css("background-image", "url(" + url + ")");
            });
        } else if (posterType !== "none") {
            $wrapper.css("background-image", "url(" + poster + "." + posterType + ")");
        }
        // If a parent element has a static position, make it relative
        if ($element.css("position") === "static") {
            $element.css("position", "relative");
        }
        $element.prepend($wrapper);
        if (typeof path === "object") {
            if (path.mp4) {
                sources += '<source src="' + path.mp4 + '.mp4" type="video/mp4">';
            }
            if (path.webm) {
                sources += '<source src="' + path.webm + '.webm" type="video/webm">';
            }
            if (path.ogv) {
                sources += '<source src="' + path.ogv + '.ogv" type="video/ogg">';
            }
            $video = vide.$video = $("<video>" + sources + "</video>");
        } else {
            $video = vide.$video = $("<video>" + '<source src="' + path + '.mp4" type="video/mp4">' + '<source src="' + path + '.webm" type="video/webm">' + '<source src="' + path + '.ogv" type="video/ogg">' + "</video>");
        }
        // https://github.com/VodkaBears/Vide/issues/110
        try {
            $video.prop({
                autoplay: settings.autoplay,
                loop: settings.loop,
                volume: settings.volume,
                muted: settings.muted,
                defaultMuted: settings.muted,
                playbackRate: settings.playbackRate,
                defaultPlaybackRate: settings.playbackRate
            });
        } catch (e) {
            throw new Error(NOT_IMPLEMENTED_MSG);
        }
        // Video alignment
        $video.css({
            margin: "auto",
            position: "absolute",
            "z-index": -1,
            top: position.y,
            left: position.x,
            "-webkit-transform": "translate(-" + position.x + ", -" + position.y + ")",
            "-ms-transform": "translate(-" + position.x + ", -" + position.y + ")",
            "-moz-transform": "translate(-" + position.x + ", -" + position.y + ")",
            transform: "translate(-" + position.x + ", -" + position.y + ")",
            // Disable visibility, while loading
            visibility: "hidden",
            opacity: 0
        }).one("canplaythrough." + PLUGIN_NAME, function() {
            vide.resize();
        }).one("playing." + PLUGIN_NAME, function() {
            $video.css({
                visibility: "visible",
                opacity: 1
            });
            $wrapper.css("background-image", "none");
        });
        // Resize event is available only for 'window'
        // Use another code solutions to detect DOM elements resizing
        $element.on("resize." + PLUGIN_NAME, function() {
            if (settings.resizing) {
                vide.resize();
            }
        });
        // Append a video
        $wrapper.append($video);
    };
    /**
   * Get a video element
   * @public
   * @returns {HTMLVideoElement}
   */
    Vide.prototype.getVideoObject = function() {
        return this.$video[0];
    };
    /**
   * Resize a video background
   * @public
   */
    Vide.prototype.resize = function() {
        if (!this.$video) {
            return;
        }
        var $wrapper = this.$wrapper;
        var $video = this.$video;
        var video = $video[0];
        // Get a native video size
        var videoHeight = video.videoHeight;
        var videoWidth = video.videoWidth;
        // Get a wrapper size
        var wrapperHeight = $wrapper.height();
        var wrapperWidth = $wrapper.width();
        if (wrapperWidth / videoWidth > wrapperHeight / videoHeight) {
            $video.css({
                // +2 pixels to prevent an empty space after transformation
                width: wrapperWidth + 2,
                height: "auto"
            });
        } else {
            $video.css({
                width: "auto",
                // +2 pixels to prevent an empty space after transformation
                height: wrapperHeight + 2
            });
        }
    };
    /**
   * Destroy a video background
   * @public
   */
    Vide.prototype.destroy = function() {
        delete $[PLUGIN_NAME].lookup[this.index];
        this.$video && this.$video.off(PLUGIN_NAME);
        this.$element.off(PLUGIN_NAME).removeData(PLUGIN_NAME);
        this.$wrapper.remove();
    };
    /**
   * Special plugin object for instances.
   * @public
   * @type {Object}
   */
    $[PLUGIN_NAME] = {
        lookup: []
    };
    /**
   * Plugin constructor
   * @param {Object|String} path
   * @param {Object|String} options
   * @returns {JQuery}
   * @constructor
   */
    $.fn[PLUGIN_NAME] = function(path, options) {
        var instance;
        this.each(function() {
            instance = $.data(this, PLUGIN_NAME);
            // Destroy the plugin instance if exists
            instance && instance.destroy();
            // Create the plugin instance
            instance = new Vide(this, path, options);
            instance.index = $[PLUGIN_NAME].lookup.push(instance) - 1;
            $.data(this, PLUGIN_NAME, instance);
        });
        return this;
    };
    $(document).ready(function() {
        var $window = $(window);
        // Window resize event listener
        $window.on("resize." + PLUGIN_NAME, function() {
            for (var len = $[PLUGIN_NAME].lookup.length, i = 0, instance; i < len; i++) {
                instance = $[PLUGIN_NAME].lookup[i];
                if (instance && instance.settings.resizing) {
                    instance.resize();
                }
            }
        });
        // https://github.com/VodkaBears/Vide/issues/68
        $window.on("unload." + PLUGIN_NAME, function() {
            return false;
        });
        // Auto initialization
        // Add 'data-vide-bg' attribute with a path to the video without extension
        // Also you can pass options throw the 'data-vide-options' attribute
        // 'data-vide-options' must be like 'muted: false, volume: 0.5'
        $(document).find("[data-" + PLUGIN_NAME + "-bg]").each(function(i, element) {
            var $element = $(element);
            var options = $element.data(PLUGIN_NAME + "-options");
            var path = $element.data(PLUGIN_NAME + "-bg");
            $element[PLUGIN_NAME](path, options);
        });
    });
});

// Sticky Plugin v1.0.4 for jQuery
// =============
// Author: Anthony Garand
// Improvements by German M. Bravo (Kronuz) and Ruud Kamphuis (ruudk)
// Improvements by Leonardo C. Daronco (daronco)
// Created: 02/14/2011
// Date: 07/20/2015
// Website: http://stickyjs.com/
// Description: Makes an element on the page stick on the screen as you scroll
//              It will only set the 'top' and 'position' of your element, you
//              might need to adjust the width in some cases.
(function(factory) {
    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define([ "jquery" ], factory);
    } else if (typeof module === "object" && module.exports) {
        // Node/CommonJS
        module.exports = factory(require("jquery"));
    } else {
        // Browser globals
        factory(jQuery);
    }
})(function($) {
    var slice = Array.prototype.slice;
    // save ref to original slice()
    var splice = Array.prototype.splice;
    // save ref to original slice()
    var defaults = {
        topSpacing: 0,
        bottomSpacing: 0,
        className: "is-sticky",
        wrapperClassName: "sticky-wrapper",
        center: false,
        getWidthFrom: "",
        widthFromWrapper: true,
        // works only when .getWidthFrom is empty
        responsiveWidth: false,
        zIndex: "auto"
    }, $window = $(window), $document = $(document), sticked = [], windowHeight = $window.height(), scroller = function() {
        var scrollTop = $window.scrollTop(), documentHeight = $document.height(), dwh = documentHeight - windowHeight, extra = scrollTop > dwh ? dwh - scrollTop : 0;
        for (var i = 0, l = sticked.length; i < l; i++) {
            var s = sticked[i], elementTop = s.stickyWrapper.offset().top, etse = elementTop - s.topSpacing - extra;
            //update height in case of dynamic content
            s.stickyWrapper.css("height", s.stickyElement.outerHeight());
            if (scrollTop <= etse) {
                if (s.currentTop !== null) {
                    s.stickyElement.css({
                        width: "",
                        position: "",
                        top: "",
                        "z-index": ""
                    });
                    s.stickyElement.parent().removeClass(s.className);
                    s.stickyElement.trigger("sticky-end", [ s ]);
                    s.currentTop = null;
                }
            } else {
                var newTop = documentHeight - s.stickyElement.outerHeight() - s.topSpacing - s.bottomSpacing - scrollTop - extra;
                if (newTop < 0) {
                    newTop = newTop + s.topSpacing;
                } else {
                    newTop = s.topSpacing;
                }
                if (s.currentTop !== newTop) {
                    var newWidth;
                    if (s.getWidthFrom) {
                        newWidth = $(s.getWidthFrom).width() || null;
                    } else if (s.widthFromWrapper) {
                        newWidth = s.stickyWrapper.width();
                    }
                    if (newWidth == null) {
                        newWidth = s.stickyElement.width();
                    }
                    s.stickyElement.css("width", newWidth).css("position", "fixed").css("top", newTop).css("z-index", s.zIndex);
                    s.stickyElement.parent().addClass(s.className);
                    if (s.currentTop === null) {
                        s.stickyElement.trigger("sticky-start", [ s ]);
                    } else {
                        // sticky is started but it have to be repositioned
                        s.stickyElement.trigger("sticky-update", [ s ]);
                    }
                    if (s.currentTop === s.topSpacing && s.currentTop > newTop || s.currentTop === null && newTop < s.topSpacing) {
                        // just reached bottom || just started to stick but bottom is already reached
                        s.stickyElement.trigger("sticky-bottom-reached", [ s ]);
                    } else if (s.currentTop !== null && newTop === s.topSpacing && s.currentTop < newTop) {
                        // sticky is started && sticked at topSpacing && overflowing from top just finished
                        s.stickyElement.trigger("sticky-bottom-unreached", [ s ]);
                    }
                    s.currentTop = newTop;
                }
                // Check if sticky has reached end of container and stop sticking
                var stickyWrapperContainer = s.stickyWrapper.parent();
                var unstick = s.stickyElement.offset().top + s.stickyElement.outerHeight() >= stickyWrapperContainer.offset().top + stickyWrapperContainer.outerHeight() && s.stickyElement.offset().top <= s.topSpacing;
                if (unstick) {
                    s.stickyElement.css("position", "absolute").css("top", "").css("bottom", 0).css("z-index", "");
                } else {
                    s.stickyElement.css("position", "fixed").css("top", newTop).css("bottom", "").css("z-index", s.zIndex);
                }
            }
        }
    }, resizer = function() {
        windowHeight = $window.height();
        for (var i = 0, l = sticked.length; i < l; i++) {
            var s = sticked[i];
            var newWidth = null;
            if (s.getWidthFrom) {
                if (s.responsiveWidth) {
                    newWidth = $(s.getWidthFrom).width();
                }
            } else if (s.widthFromWrapper) {
                newWidth = s.stickyWrapper.width();
            }
            if (newWidth != null) {
                s.stickyElement.css("width", newWidth);
            }
        }
    }, methods = {
        init: function(options) {
            return this.each(function() {
                var o = $.extend({}, defaults, options);
                var stickyElement = $(this);
                var stickyId = stickyElement.attr("id");
                var wrapperId = stickyId ? stickyId + "-" + defaults.wrapperClassName : defaults.wrapperClassName;
                var wrapper = $("<div></div>").attr("id", wrapperId).addClass(o.wrapperClassName);
                stickyElement.wrapAll(function() {
                    if ($(this).parent("#" + wrapperId).length == 0) {
                        return wrapper;
                    }
                });
                var stickyWrapper = stickyElement.parent();
                if (o.center) {
                    stickyWrapper.css({
                        width: stickyElement.outerWidth(),
                        marginLeft: "auto",
                        marginRight: "auto"
                    });
                }
                if (stickyElement.css("float") === "right") {
                    stickyElement.css({
                        float: "none"
                    }).parent().css({
                        float: "right"
                    });
                }
                o.stickyElement = stickyElement;
                o.stickyWrapper = stickyWrapper;
                o.currentTop = null;
                sticked.push(o);
                methods.setWrapperHeight(this);
                methods.setupChangeListeners(this);
            });
        },
        setWrapperHeight: function(stickyElement) {
            var element = $(stickyElement);
            var stickyWrapper = element.parent();
            if (stickyWrapper) {
                stickyWrapper.css("height", element.outerHeight());
            }
        },
        setupChangeListeners: function(stickyElement) {
            if (window.MutationObserver) {
                var mutationObserver = new window.MutationObserver(function(mutations) {
                    if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) {
                        methods.setWrapperHeight(stickyElement);
                    }
                });
                mutationObserver.observe(stickyElement, {
                    subtree: true,
                    childList: true
                });
            } else {
                if (window.addEventListener) {
                    stickyElement.addEventListener("DOMNodeInserted", function() {
                        methods.setWrapperHeight(stickyElement);
                    }, false);
                    stickyElement.addEventListener("DOMNodeRemoved", function() {
                        methods.setWrapperHeight(stickyElement);
                    }, false);
                } else if (window.attachEvent) {
                    stickyElement.attachEvent("onDOMNodeInserted", function() {
                        methods.setWrapperHeight(stickyElement);
                    });
                    stickyElement.attachEvent("onDOMNodeRemoved", function() {
                        methods.setWrapperHeight(stickyElement);
                    });
                }
            }
        },
        update: scroller,
        unstick: function(options) {
            return this.each(function() {
                var that = this;
                var unstickyElement = $(that);
                var removeIdx = -1;
                var i = sticked.length;
                while (i-- > 0) {
                    if (sticked[i].stickyElement.get(0) === that) {
                        splice.call(sticked, i, 1);
                        removeIdx = i;
                    }
                }
                if (removeIdx !== -1) {
                    unstickyElement.unwrap();
                    unstickyElement.css({
                        width: "",
                        position: "",
                        top: "",
                        float: "",
                        "z-index": ""
                    });
                }
            });
        }
    };
    // should be more efficient than using $window.scroll(scroller) and $window.resize(resizer):
    if (window.addEventListener) {
        window.addEventListener("scroll", scroller, false);
        window.addEventListener("resize", resizer, false);
    } else if (window.attachEvent) {
        window.attachEvent("onscroll", scroller);
        window.attachEvent("onresize", resizer);
    }
    $.fn.sticky = function(method) {
        if (methods[method]) {
            return methods[method].apply(this, slice.call(arguments, 1));
        } else if (typeof method === "object" || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error("Method " + method + " does not exist on jQuery.sticky");
        }
    };
    $.fn.unstick = function(method) {
        if (methods[method]) {
            return methods[method].apply(this, slice.call(arguments, 1));
        } else if (typeof method === "object" || !method) {
            return methods.unstick.apply(this, arguments);
        } else {
            $.error("Method " + method + " does not exist on jQuery.sticky");
        }
    };
    $(function() {
        setTimeout(scroller, 0);
    });
});

(function($) {
    "use strict";
    // Start of use strict
    $(document).ready(function() {
        $(window).trigger("resize");
        init_mobile_nav_toggle();
        init_classic_menu();
        video_bg_init();
    });
    $(window).resize(function() {
        init_classic_menu_resize();
        js_height_init();
    });
    function init_classic_menu_resize() {
        // Mobile menu style toggle
        if ($(window).width() <= 899) {
            $(".navigation").addClass("mobile-on");
        } else if ($(window).width() > 899) {
            $(".navigation").removeClass("mobile-on");
        }
    }
    function init_classic_menu() {
        // Navbar sticky
        $(window).bind("scroll", function() {
            if ($(window).scrollTop() > $(".home-section").height()) {
                $(".navigation").sticky({
                    topSpacing: 0
                });
            } else {
                $(".navigation").unstick();
            }
        });
    }
    // Hamburger Menu - Toggle
    function init_mobile_nav_toggle() {
        var hamburger = $("#js-mobile-menu").off();
        var desktop_nav = $("#js-navigation-menu");
        desktop_nav.removeClass("show");
        hamburger.on("click", function(e) {
            e.preventDefault();
            this.classList.contains("is-active") === true ? this.classList.remove("is-active") : this.classList.add("is-active");
            desktop_nav.slideToggle(function() {
                if ($(this).is(":hidden")) {
                    $(this).removeAttr("style");
                }
            });
        });
    }
})(jQuery);

// End of use strict
function video_bg_init() {
    $("#video-bg").vide({
        mp4: "video/newOrleans",
        webm: "video/newOrleans",
        ogv: "video/newOrleans",
        poster: "video/newOrleans.jpg"
    }, {
        position: "50% 50%",
        posterType: "jpg"
    });
}

function js_height_init() {
    (function($) {
        $(".js-height-full").height($(window).height());
        $(".js-height-parent").each(function() {
            $(this).height($(this).parent().first().height());
        });
    })(jQuery);
}

// Sub menu
var mnHasSub = $(".mn-has-sub");

var mnThisLi;

$(".mobile-on .mn-has-sub").find(".fa:first").removeClass("fa-angle-right").addClass("fa-angle-down");

mnHasSub.click(function() {
    if ($(".navigation").hasClass("mobile-on")) {
        mnThisLi = $(this).parent("li:first");
        if (mnThisLi.hasClass("js-opened")) {
            mnThisLi.find(".submenu:first").slideUp(function() {
                mnThisLi.removeClass("js-opened");
                mnThisLi.find(".mn-has-sub").find(".fa:first").removeClass("fa-angle-up").addClass("fa-angle-down");
            });
        } else {
            $(this).find(".fa:first").removeClass("fa-angle-down").addClass("fa-angle-up");
            mnThisLi.addClass("js-opened");
            mnThisLi.find(".submenu:first").slideDown();
        }
        return false;
    } else {}
});

mnThisLi = mnHasSub.parent("li");

mnThisLi.hover(function() {
    if (!$(".navigation").hasClass("mobile-on")) {
        $(this).find(".submenu:first").stop(true, true).fadeIn("fast");
    }
}, function() {
    if (!$(".navigation").hasClass("mobile-on")) {
        $(this).find(".submenu:first").stop(true, true).delay(100).fadeOut("fast");
    }
});

// Countdown Init Init
$(document).ready(function() {
    var countdown = $(".countdown");
    var data_finish_date = countdown.attr("data-finish-date");
    var data_UTC = countdown.attr("data-UTC");
    var data_finish_message = countdown.attr("data-finish-message");
    countdown.downCount({
        date: data_finish_date,
        offset: data_UTC
    }, function() {
        alert(data_finish_message);
    });
});

/**
 * downCount: Simple Countdown clock with offset
 * Author: Sonny T. <hi@sonnyt.com>, sonnyt.com
 */
(function($) {
    $.fn.downCount = function(options, callback) {
        var settings = $.extend({
            date: null,
            offset: null
        }, options);
        // Throw error if date is not set
        if (!settings.date) {
            $.error("Date is not defined.");
        }
        // Throw error if date is set incorectly
        if (!Date.parse(settings.date)) {
            $.error("Incorrect date format, it should look like this, 12/24/2012 12:00:00.");
        }
        // Save container
        var container = this;
        /**
         * Change client's local date to match offset timezone
         * @return {Object} Fixed Date object.
         */
        var currentDate = function() {
            // get client's current date
            var date = new Date();
            // turn date to utc
            var utc = date.getTime() + date.getTimezoneOffset() * 6e4;
            // set new Date object
            var new_date = new Date(utc + 36e5 * settings.offset);
            return new_date;
        };
        /**
         * Main downCount function that calculates everything
         */
        function countdown() {
            var target_date = new Date(settings.date), // set target date
            current_date = currentDate();
            // get fixed current date
            // difference of dates
            var difference = target_date - current_date;
            // if difference is negative than it's pass the target date
            if (difference < 0) {
                // stop timer
                clearInterval(interval);
                if (callback && typeof callback === "function") callback();
                return;
            }
            // basic math variables
            var _second = 1e3, _minute = _second * 60, _hour = _minute * 60, _day = _hour * 24;
            // calculate dates
            var days = Math.floor(difference / _day), hours = Math.floor(difference % _day / _hour), minutes = Math.floor(difference % _hour / _minute), seconds = Math.floor(difference % _minute / _second);
            // fix dates so that it will show two digets
            days = String(days).length >= 2 ? days : "0" + days;
            hours = String(hours).length >= 2 ? hours : "0" + hours;
            minutes = String(minutes).length >= 2 ? minutes : "0" + minutes;
            seconds = String(seconds).length >= 2 ? seconds : "0" + seconds;
            // based on the date change the refrence wording
            var ref_days = days === 1 ? "day" : "days", ref_hours = hours === 1 ? "hour" : "hours", ref_minutes = minutes === 1 ? "minute" : "minutes", ref_seconds = seconds === 1 ? "second" : "seconds";
            // set to DOM
            container.find(".days").text(days);
            container.find(".hours").text(hours);
            container.find(".minutes").text(minutes);
            container.find(".seconds").text(seconds);
            container.find(".days_ref").text(ref_days);
            container.find(".hours_ref").text(ref_hours);
            container.find(".minutes_ref").text(ref_minutes);
            container.find(".seconds_ref").text(ref_seconds);
        }
        // start
        var interval = setInterval(countdown, 300);
    };
})(jQuery);